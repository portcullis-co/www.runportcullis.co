import { a as createComponent, r as renderTemplate, m as maybeRenderHead, u as unescapeHTML } from './astro/server_DlAcna1r.mjs';
import 'clsx';

const html = "<p>It‚Äôs a brand new year and that means plans and being made for product direction and strategy for the next 364 days. With 2024 being the birth of Portcullis as a company, it‚Äôs hard to look at 2025 with anything but wide-eyed excitement for what challenges and growth opportunities present themselves this year.</p>\n<p>Something we‚Äôre really excited for is all of the fast-pased developments happening in the overall ecosystem. From performance optimizations to new features that will make this real-time warehouse even more powerful, 2025 is shaping up to be a transformative year for Clickhouse. Let‚Äôs dive into some of the key areas we‚Äôll be focusing on.</p>\n<h2 id=\"the-year-of-dancing-data-\">The year of dancing data  üï∫</h2>\n<p>If there is anything we want to highlight on the 2025 roadmap, it‚Äôs that data is about to get a lot easier to move into and out of Clickhouse with tons of new interfaces and API features being added.</p>\n<h3 id=\"remote-and-cloud-database-engines\">Remote and Cloud database engines</h3>\n<p>One super exciting feature coming to Clickhouse in 2025 is expanded support for remote and cloud database engines. This will enable users to attach a database from a remote Clickhouse server, making it easier than ever to build distributed data architectures.</p>\n<p>The new engines will support both read and write operations, with optimized performance for large-scale data transfers.</p>\n<h3 id=\"drivers-for-udfs\">Drivers for UDFs</h3>\n<p>In <a href=\"https://github.com/ClickHouse/ClickHouse/issues/71172\">Issue #71172</a> on the roadmap, it‚Äôs planned to allow users to write code of configuration for a UDF in any arbitrary languagedirectly in the <code>CREATE FUNCTION</code> statement.</p>\n<p>This feature would broaden the flexibility of Clickhouse UDF and make the developer experience more enjoyable.</p>\n<h3 id=\"tabular-insert-handler\">Tabular Insert handler</h3>\n<p>The <a href=\"https://github.com/ClickHouse/ClickHouse/pull/64336\">tabular Insert hander</a> seeks to add another exciting addition that will streamline data ingestion. This feature will allow users to insert data by simply passing queries like <code>tabular/database/table.csv</code>, which are which are equal to the SQL query <code>SELECT * FROM database.table FORMAT CSV</code>.</p>\n<p>Additional parameters can be specified in the path, such as <code>select</code>, <code>columns</code>, <code>where</code>, <code>order</code>, which are combined with the query. For example <code>tabular/table?columns=a,b&#x26;where=a>1&#x26;order=a ASC, b DESC</code> is equal to <code>SELECT a,b FROM table WHERE a > 1 ORDER BY a ASC, b DESC</code>.</p>\n<h3 id=\"implicit-inserts\">Implicit Inserts</h3>\n<p><a href=\"https://github.com/ClickHouse/ClickHouse/issues/38775\">Issue #38775</a> seeks to enable event simpler data upload via implicit inserts for HTTP PUT request and POST with form file upload where the query is not specified. It makes the assumption that it is an INSERT query into a table with the name as the corresponding file name, with format autodetected from the file name.</p>\n<h3 id=\"http-event-stream\">HTTP Event Stream</h3>\n<p>Another exciting feature planned for 2025 is HTTP Event Stream support, which will allow for real-time data streaming directly into and from Clickhouse via HTTP. This feature will enable applications to maintain an open connection and receive updates as new data becomes available, making it perfect for building real-time dashboards and monitoring systems.</p>\n<h2 id=\"a-roadmap-for-storage-success-Ô∏è\">A roadmap for storage success üó∫Ô∏è</h2>\n<p>The next category of features we‚Äôre excited to see this year is new and more efficient methods of storage and optimizations on storage methods currently provided.</p>\n<h3 id=\"json-data-type-from-beta-to-production\">JSON data type from beta to production</h3>\n<p>One of the most anticipated storage features for 2025 is the promotion of the JSON data type from beta to production status. This native JSON support will enable more efficient storage and querying of JSON data, with improved performance and reduced complexity compared to current workarounds. The feature will include optimized indexing strategies and enhanced JSON-specific functions, making it easier for developers to work with semi-structured data in Clickhouse.</p>\n<h3 id=\"shardedmap-data-type\">ShardedMap data type</h3>\n<p>The ShardedMap data type is another exciting addition coming to Clickhouse. This new data structure will allow for efficient storage and querying of key-value pairs across distributed environments. It‚Äôs particularly useful for applications requiring fast lookups across large datasets while maintaining data locality within shards.</p>\n<h3 id=\"time-data-type\">Time data type</h3>\n<p>The Time data type is a new addition planned for 2025 that will provide native support for time-only values without dates. This will be particularly useful for applications that need to work with recurring schedules, time-series data, or daily patterns. The implementation will include optimized storage and comparison operations, making time-based queries more efficient.</p>\n<h3 id=\"production-ready-vector-search\">Production-ready vector search</h3>\n<p>Vector search capabilities are moving from experimental to production-ready, bringing robust support for similarity search across high-dimensional vectors. This feature will enable advanced machine learning applications, semantic search, and recommendation systems directly within Clickhouse. The implementation includes optimized index structures and distance calculation methods, making it possible to perform efficient nearest neighbor searches across massive vector datasets.</p>\n<h3 id=\"transactions-for-replicated-tables\">Transactions for Replicated tables</h3>\n<p>A significant enhancement planned for replicated tables is the introduction of transactions which will ensure atomic operations across distributed environments. This will make it easier to maintain data consistency in complex write scenarios. The implementation will include support for both single-table and multi-table transactions, with configurable isolation levels to balance consistency requirements with performance needs.</p>\n<h3 id=\"unique-key-constraint\">Unique key constraint</h3>\n<p>Another significant enhancement planned for Clickhouse‚Äôs roadmap is the introduction of unique key constraints for tables. This feature will allow developers to enforce data uniqueness at the database level, preventing duplicate entries and maintaining data integrity. The implementation will include support for both single-column and composite unique keys, with optimized performance for constraint checking during insert and update operations.</p>\n<h2 id=\"new-year-new-query-engines-Ô∏è\">New year, new query engines üèéÔ∏è</h2>\n<p>There‚Äôs a bunch of planned optimizations planned in 2025 such as new query engines, ans optimizations to existing ones which will make complex analytical queries faster and more efficient than ever. These improvements focus on both performance and functionality, giving developers more tools to build sophisticated data applications.</p>\n<h3 id=\"materialized-cte\">Materialized CTE</h3>\n<p>Materialized Common Table Expressions (CTEs) are coming to Clickhouse, bringing significant performance improvements for complex queries. This feature will allow intermediate results to be stored and reused across multiple parts of a query, reducing redundant computations. The implementation includes intelligent materialization decisions based on query cost estimates, ensuring optimal performance for queries with repeated CTE references.</p>\n<h3 id=\"on-disk-query-cache\">On-disk query cache</h3>\n<p>The on-disk query cache is another performance-focused feature coming to Clickhouse in 2025. This enhancement will allow frequently executed queries to store their results on disk, significantly reducing computation overhead for repeated queries. The implementation includes intelligent cache invalidation strategies and configurable cache sizes to optimize storage usage while maintaining query performance.</p>\n<h3 id=\"streaming-queries\">Streaming queries</h3>\n<p>Streaming queries are getting a major upgrade in 2025, with improvements to how Clickhouse handles continuous data processing. This enhancement will allow for more efficient processing of real-time data streams, with better memory management and reduced latency. The feature will include support for windowing operations and stateful processing, making it easier to build real-time analytics applications.</p>\n<h3 id=\"prewhere-to-work-with-the-final-clause\">PREWHERE to work with the FINAL clause</h3>\n<p><a href=\"https://github.com/ClickHouse/ClickHouse/pull/70210\">Issue #70210</a> adds the ability for PREWHERE to work with the FINAL clause. This enhancement will improve query performance by allowing the PREWHERE optimization to be applied even when using FINAL to get the latest versions of records. The implementation will include intelligent optimization strategies to ensure optimal execution plans for queries combining these clauses.</p>\n<h3 id=\"join-reordering-based-on-finer-grained-statistics\">JOIN reordering based on finer-grained statistics</h3>\n<p>JOIN reordering in Clickhouse is getting smarter with the introduction of finer-grained statistics collection and analysis. This enhancement will enable the query optimizer to make better decisions about join order based on detailed table statistics, column distributions, and historical query patterns. The result will be faster execution times for complex joins, especially in scenarios involving multiple tables with varying sizes and data distributions.</p>\n<h3 id=\"using-a-partition-key-to-optimize-joins\">Using a partition key to optimize JOINs</h3>\n<p>Another optimization coming to Clickhouse is the ability to use partition keys to optimize JOIN operations. This feature will allow the query engine to leverage partitioning information to reduce the amount of data that needs to be processed during joins, resulting in faster query execution. The implementation will include intelligent partition pruning strategies and improved data locality for distributed joins.</p>\n<p>This optimization is particularly valuable for large-scale distributed deployments where data locality can significantly impact query performance.</p>\n<h2 id=\"looking-ahead\">Looking ahead üîÆ</h2>\n<p>These planned features and improvements for 2025 represent just a fraction of what‚Äôs in store for Clickhouse. As the platform continues to evolve, we‚Äôre excited to see how these enhancements will enable new use cases and improve existing workflows for developers and data teams alike.</p>\n<p>If you‚Äôd like to discuss how Portcullis can help you prepare for some of these changes, or explore support in any of the massive feature-set that Clickhouse already has, let‚Äôs hop on a call soon.</p>";

				const frontmatter = {"title":"The 2025 Clickhouse Roadmap: An Overview","description":"From performance optimizations to new features that will make this real-time warehouse even more powerful, 2025 is shaping up to be a transformative year for the platform. Let's dive into some of the key areas we'll be focusing on.","pubDate":"Jan 2 2025","cover":"/blog/new-year-2025.png","category":"insights"};
				const file = "/Users/jdbohrman/www.runportcullis.co/src/content/blog/clickhouse-2025-roadmap.md";
				const url = undefined;
				function rawContent() {
					return "\nIt‚Äôs a brand new year and that means plans and being made for product direction and strategy for the next 364 days. With 2024 being the birth of Portcullis as a company, it‚Äôs hard to look at 2025 with anything but wide-eyed excitement for what challenges and growth opportunities present themselves this year. \n\nSomething we‚Äôre really excited for is all of the fast-pased developments happening in the overall ecosystem. From performance optimizations to new features that will make this real-time warehouse even more powerful, 2025 is shaping up to be a transformative year for Clickhouse. Let's dive into some of the key areas we'll be focusing on.\n\n## The year of dancing data  üï∫\n\nIf there is anything we want to highlight on the 2025 roadmap, it‚Äôs that data is about to get a lot easier to move into and out of Clickhouse with tons of new interfaces and API features being added. \n\n### Remote and Cloud database engines\n\nOne super exciting feature coming to Clickhouse in 2025 is expanded support for remote and cloud database engines. This will enable users to attach a database from a remote Clickhouse server, making it easier than ever to build distributed data architectures. \n\nThe new engines will support both read and write operations, with optimized performance for large-scale data transfers.\n\n### Drivers for UDFs\n\nIn [Issue #71172](https://github.com/ClickHouse/ClickHouse/issues/71172) on the roadmap, it‚Äôs planned to allow users to write code of configuration for a UDF in any arbitrary languagedirectly in the `CREATE FUNCTION` statement. \n\nThis feature would broaden the flexibility of Clickhouse UDF and make the developer experience more enjoyable.  \n\n### Tabular Insert handler\n\nThe [tabular Insert hander](https://github.com/ClickHouse/ClickHouse/pull/64336) seeks to add another exciting addition that will streamline data ingestion. This feature will allow users to insert data by simply passing queries like `tabular/database/table.csv`, which are which are equal to the SQL query `SELECT * FROM database.table FORMAT CSV`. \n\nAdditional parameters can be specified in the path, such as `select`, `columns`, `where`, `order`, which are combined with the query. For example `tabular/table?columns=a,b&where=a>1&order=a ASC, b DESC` is equal to `SELECT a,b FROM table WHERE a > 1 ORDER BY a ASC, b DESC`.\n\n### Implicit Inserts\n\n[Issue #38775](https://github.com/ClickHouse/ClickHouse/issues/38775) seeks to enable event simpler data upload via implicit inserts for HTTP PUT request and POST with form file upload where the query is not specified. It makes the assumption that it is an INSERT query into a table with the name as the corresponding file name, with format autodetected from the file name.\n\n### HTTP Event Stream\n\nAnother exciting feature planned for 2025 is HTTP Event Stream support, which will allow for real-time data streaming directly into and from Clickhouse via HTTP. This feature will enable applications to maintain an open connection and receive updates as new data becomes available, making it perfect for building real-time dashboards and monitoring systems. \n\n## A roadmap for storage success üó∫Ô∏è\n\nThe next category of features we‚Äôre excited to see this year is new and more efficient methods of storage and optimizations on storage methods currently provided.   \n\n### JSON data type from beta to production\n\nOne of the most anticipated storage features for 2025 is the promotion of the JSON data type from beta to production status. This native JSON support will enable more efficient storage and querying of JSON data, with improved performance and reduced complexity compared to current workarounds. The feature will include optimized indexing strategies and enhanced JSON-specific functions, making it easier for developers to work with semi-structured data in Clickhouse.\n\n### ShardedMap data type\n\nThe ShardedMap data type is another exciting addition coming to Clickhouse. This new data structure will allow for efficient storage and querying of key-value pairs across distributed environments. It's particularly useful for applications requiring fast lookups across large datasets while maintaining data locality within shards.\n\n### Time data type\n\nThe Time data type is a new addition planned for 2025 that will provide native support for time-only values without dates. This will be particularly useful for applications that need to work with recurring schedules, time-series data, or daily patterns. The implementation will include optimized storage and comparison operations, making time-based queries more efficient.\n\n### Production-ready vector search\n\nVector search capabilities are moving from experimental to production-ready, bringing robust support for similarity search across high-dimensional vectors. This feature will enable advanced machine learning applications, semantic search, and recommendation systems directly within Clickhouse. The implementation includes optimized index structures and distance calculation methods, making it possible to perform efficient nearest neighbor searches across massive vector datasets.\n\n### Transactions for Replicated tables\n\nA significant enhancement planned for replicated tables is the introduction of transactions which will ensure atomic operations across distributed environments. This will make it easier to maintain data consistency in complex write scenarios. The implementation will include support for both single-table and multi-table transactions, with configurable isolation levels to balance consistency requirements with performance needs.\n\n### Unique key constraint\n\nAnother significant enhancement planned for Clickhouse‚Äôs roadmap is the introduction of unique key constraints for tables. This feature will allow developers to enforce data uniqueness at the database level, preventing duplicate entries and maintaining data integrity. The implementation will include support for both single-column and composite unique keys, with optimized performance for constraint checking during insert and update operations.\n\n## New year, new query engines üèéÔ∏è\n\nThere‚Äôs a bunch of planned optimizations planned in 2025 such as new query engines, ans optimizations to existing ones which will make complex analytical queries faster and more efficient than ever. These improvements focus on both performance and functionality, giving developers more tools to build sophisticated data applications.\n\n### Materialized CTE\n\nMaterialized Common Table Expressions (CTEs) are coming to Clickhouse, bringing significant performance improvements for complex queries. This feature will allow intermediate results to be stored and reused across multiple parts of a query, reducing redundant computations. The implementation includes intelligent materialization decisions based on query cost estimates, ensuring optimal performance for queries with repeated CTE references.\n\n### On-disk query cache\n\nThe on-disk query cache is another performance-focused feature coming to Clickhouse in 2025. This enhancement will allow frequently executed queries to store their results on disk, significantly reducing computation overhead for repeated queries. The implementation includes intelligent cache invalidation strategies and configurable cache sizes to optimize storage usage while maintaining query performance.\n\n### Streaming queries\n\nStreaming queries are getting a major upgrade in 2025, with improvements to how Clickhouse handles continuous data processing. This enhancement will allow for more efficient processing of real-time data streams, with better memory management and reduced latency. The feature will include support for windowing operations and stateful processing, making it easier to build real-time analytics applications.\n\n### PREWHERE to work with the FINAL clause\n\n[Issue #70210](https://github.com/ClickHouse/ClickHouse/pull/70210) adds the ability for PREWHERE to work with the FINAL clause. This enhancement will improve query performance by allowing the PREWHERE optimization to be applied even when using FINAL to get the latest versions of records. The implementation will include intelligent optimization strategies to ensure optimal execution plans for queries combining these clauses.\n\n### JOIN reordering based on finer-grained statistics\n\nJOIN reordering in Clickhouse is getting smarter with the introduction of finer-grained statistics collection and analysis. This enhancement will enable the query optimizer to make better decisions about join order based on detailed table statistics, column distributions, and historical query patterns. The result will be faster execution times for complex joins, especially in scenarios involving multiple tables with varying sizes and data distributions.\n\n### Using a partition key to optimize JOINs\n\nAnother optimization coming to Clickhouse is the ability to use partition keys to optimize JOIN operations. This feature will allow the query engine to leverage partitioning information to reduce the amount of data that needs to be processed during joins, resulting in faster query execution. The implementation will include intelligent partition pruning strategies and improved data locality for distributed joins.\n\nThis optimization is particularly valuable for large-scale distributed deployments where data locality can significantly impact query performance.\n\n## Looking ahead üîÆ\n\nThese planned features and improvements for 2025 represent just a fraction of what's in store for Clickhouse. As the platform continues to evolve, we're excited to see how these enhancements will enable new use cases and improve existing workflows for developers and data teams alike.\n\nIf you‚Äôd like to discuss how Portcullis can help you prepare for some of these changes, or explore support in any of the massive feature-set that Clickhouse already has, let‚Äôs hop on a call soon.";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"the-year-of-dancing-data-","text":"The year of dancing data  üï∫"},{"depth":3,"slug":"remote-and-cloud-database-engines","text":"Remote and Cloud database engines"},{"depth":3,"slug":"drivers-for-udfs","text":"Drivers for UDFs"},{"depth":3,"slug":"tabular-insert-handler","text":"Tabular Insert handler"},{"depth":3,"slug":"implicit-inserts","text":"Implicit Inserts"},{"depth":3,"slug":"http-event-stream","text":"HTTP Event Stream"},{"depth":2,"slug":"a-roadmap-for-storage-success-Ô∏è","text":"A roadmap for storage success üó∫Ô∏è"},{"depth":3,"slug":"json-data-type-from-beta-to-production","text":"JSON data type from beta to production"},{"depth":3,"slug":"shardedmap-data-type","text":"ShardedMap data type"},{"depth":3,"slug":"time-data-type","text":"Time data type"},{"depth":3,"slug":"production-ready-vector-search","text":"Production-ready vector search"},{"depth":3,"slug":"transactions-for-replicated-tables","text":"Transactions for Replicated tables"},{"depth":3,"slug":"unique-key-constraint","text":"Unique key constraint"},{"depth":2,"slug":"new-year-new-query-engines-Ô∏è","text":"New year, new query engines üèéÔ∏è"},{"depth":3,"slug":"materialized-cte","text":"Materialized CTE"},{"depth":3,"slug":"on-disk-query-cache","text":"On-disk query cache"},{"depth":3,"slug":"streaming-queries","text":"Streaming queries"},{"depth":3,"slug":"prewhere-to-work-with-the-final-clause","text":"PREWHERE to work with the FINAL clause"},{"depth":3,"slug":"join-reordering-based-on-finer-grained-statistics","text":"JOIN reordering based on finer-grained statistics"},{"depth":3,"slug":"using-a-partition-key-to-optimize-joins","text":"Using a partition key to optimize JOINs"},{"depth":2,"slug":"looking-ahead","text":"Looking ahead üîÆ"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
